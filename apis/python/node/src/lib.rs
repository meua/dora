#![allow(clippy::borrow_deref_ref)] // clippy warns about code generated by #[pymethods]

use arrow2::array::PrimitiveArray;
use arrow2::{array::Array, datatypes::Field, ffi};

use dora_node_api::{dora_core::config::NodeId, DoraNode, Input};
use dora_operator_api_python::{metadata_to_pydict, pydict_to_metadata};
use eyre::{Context, ContextCompat, Result};
use flume::Receiver;
use pyo3::ffi::Py_uintptr_t;
use pyo3::{prelude::*, types::PyDict};
#[pyclass]
pub struct Node {
    id: NodeId,
    inputs: Receiver<Input>,
    node: DoraNode,
}

pub struct PyInput(Input);

// Taken from arrow2/example: https://github.com/jorgecarleitao/arrow2/blob/main/arrow-pyarrow-integration-testing/src/lib.rs
fn to_py_array(array: Box<dyn Array>, py: Python) -> PyResult<PyObject> {
    let schema = Box::new(ffi::export_field_to_c(&Field::new(
        "",
        array.data_type().clone(),
        true,
    )));
    let array = Box::new(ffi::export_array_to_c(array));

    let schema_ptr: *const arrow2::ffi::ArrowSchema = &*schema;
    let array_ptr: *const arrow2::ffi::ArrowArray = &*array;

    let pa = py.import("pyarrow")?;

    let array = pa.getattr("Array")?.call_method1(
        "_import_from_c",
        (array_ptr as Py_uintptr_t, schema_ptr as Py_uintptr_t),
    )?;

    Ok(array.to_object(py))
}

// Taken from arrow2/example: https://github.com/jorgecarleitao/arrow2/blob/main/arrow-pyarrow-integration-testing/src/lib.rs
fn to_rust_array(ob: PyObject, py: Python) -> PyResult<Box<dyn Array>> {
    // prepare a pointer to receive the Array struct
    let array = Box::new(ffi::ArrowArray::empty());
    let schema = Box::new(ffi::ArrowSchema::empty());

    let array_ptr = &*array as *const ffi::ArrowArray;
    let schema_ptr = &*schema as *const ffi::ArrowSchema;

    // make the conversion through PyArrow's private API
    // this changes the pointer's memory and is thus unsafe. In particular, `_export_to_c` can go out of bounds
    ob.call_method1(
        py,
        "_export_to_c",
        (array_ptr as Py_uintptr_t, schema_ptr as Py_uintptr_t),
    )?;

    let field = unsafe {
        ffi::import_field_from_c(schema.as_ref()).wrap_err("Could not parse output array")?
    };

    let array = unsafe {
        ffi::import_array_from_c(*array, field.data_type)
            .wrap_err("Could not parse output array")?
    };

    Ok(array)
}

fn to_pyarrow(input: Input, py: Python) -> PyObject {
    let data = input.data();

    let array = unsafe { arrow2::ffi::mmap::slice(&data) };
    let array_data = to_py_array(Box::new(array), py).unwrap();
    (
        input.id.to_string(),
        array_data,
        metadata_to_pydict(input.metadata(), py),
    )
        .into_py(py)
}

#[pymethods]
impl Node {
    #[new]
    pub fn new() -> Result<Self> {
        let id = {
            let raw =
                std::env::var("DORA_NODE_ID").wrap_err("env variable DORA_NODE_ID must be set")?;
            serde_yaml::from_str(&raw).context("failed to deserialize operator config")?
        };

        let mut node = DoraNode::init_from_env()?;
        let inputs = node.inputs()?;

        Ok(Node { id, inputs, node })
    }

    #[allow(clippy::should_implement_trait)]
    pub fn next(&mut self, py: Python) -> PyResult<Option<PyObject>> {
        self.__next__(py)
    }

    pub fn __next__(&mut self, py: Python) -> PyResult<Option<PyObject>> {
        Ok(self.inputs.recv().ok().map(|input| to_pyarrow(input, py)))
    }

    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
        slf
    }

    pub fn send_output(
        &mut self,
        output_id: String,
        data: PyObject,
        metadata: Option<&PyDict>,
        py: Python,
    ) -> Result<()> {
        let buffer = to_rust_array(data, py).unwrap();
        let data = buffer
            .as_any()
            .downcast_ref::<PrimitiveArray<u8>>()
            .wrap_err("Could not cast sent output to arrow uint8 array")
            .unwrap()
            .values();
        let metadata = pydict_to_metadata(metadata)?;
        self.node
            .send_output(&output_id.into(), metadata, data.len(), |out| {
                out.copy_from_slice(&data);
            })
            .wrap_err("Could not send output")
    }

    pub fn id(&self) -> String {
        self.id.to_string()
    }
}

#[pyfunction]
fn start_runtime() -> Result<()> {
    dora_runtime::main()
        .wrap_err("Python Dora Runtime failed.")
        .unwrap();
    Ok(())
}

#[pymodule]
fn dora(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(start_runtime, m)?)?;
    m.add_class::<Node>().unwrap();
    Ok(())
}
